# Week3



### 亂數 

```python
import time
import math

SEED_MAX = 9999997
seed = time.time()%SEED_MAX

def random():
    global seed
    seed = (seed+37) % SEED_MAX
    x = math.sin(seed) * 93177      #乘上任一質數
    return x - math.floor(x)

for _ in range(10):
  print(random())
```



### 疊代

```python
# Gibbs Algorithm 的範例
# 問題：機率式有限狀態機，P(a=>b)=0.3, P(b=>a)=0.5 ; P(a=>b)=0.7, P(b=>b)=0.5
# 目標：尋找該「機率式有限狀態機」的穩態，也就是 P(a) = ?, P(b)=? 時系統會達到平衡。
from prob import P
import math

def gibbs (P):
    P0 = {'a': P['a'], 'b': P['b'] }
    print('P0 = {}'.format(P0))
    while True:
        P1 = { # 下一輪的機率分布。
            'a': P0['a'] * P['a=>a'] + P0['b'] * P['b=>a'], #上一輪在A,這輪還在A;上一輪在B,這輪轉到A,兩個機率相加為下一輪在A的機率
            'b': P0['a'] * P['a=>b'] + P0['b'] * P['b=>b']  #上一輪在A,這輪轉到B;上一輪在B,這輪還在B,兩個機率相加為下一輪在B的機率
        }
        print('P1 = {}'.format(P1))
        da = P1['a'] - P0['a']
        db = P1['b'] - P0['b'] # 兩輪間的差異。
        step = math.sqrt(da * da + db * db) # 差異的大小
        P0 = P1
        if (step < 0.001): break # 假如差異夠小的時候，就可以停止了。,步伐小於0.001

    print('標準答案:P(a)=5/8={} P(b)=3/8={}'.format(5 / 8, 3 / 8)) # 印出標準答案，以便看看我們找到的答案是否夠接近。

gibbs(P)
```



### 馬可夫

```python
# 參考： 自然語言處理 -- Hidden Markov Model http://cpmarkchang.logdown.com/posts/192352
from prob import P

def markov(s):
    p = P[s[0]]
    for i in range(1, len(s)):
        key = s[i-1]+'=>'+s[i]
        p = p * P[key]
    return p

seq = ['b', 'a', 'b', 'b']

print('P(b a b b) = P(b) P(b=>a) P(a=>b) P(b=>b) = {}*{}*{}*{} = {}'.format(P['b'], P['b=>a'], P['a=>b'], P['b=>b'], markov(seq)))
```



### 收斂

***f(x) = x^2***

* -1 < x < 1

* x = 1 => 1

  

### 發散

***f(x) = x + 1***



***f(x) = x^2***

* x > 1
* x < -1



### 振盪



### 渾沌(chaos) 

繞來繞去,不重複,不發散,不收斂



### 爬山演算法

為通用的<優化演算法>,通常用來找<極大值>,

